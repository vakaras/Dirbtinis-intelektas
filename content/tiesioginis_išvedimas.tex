\chapter{Tiesioginis išvedimas}

\section{Įvadas}

Tiesioginis išvedimas yra vienas iš dviejų pagrindinių išvedimo metodų,
naudojamų su produkcijos taisyklėmis, ir logikoje gali būti
apibrėžtas, kaip pakartotinas \emph{modus ponens} taisyklės
taikymas.

Tiesioginio išvedimo uždavinį galime apibrėžti, kaip trejetą
$<R, F, G>$, kur
\begin{description}
  \item[$R$] – taisyklių aibė;
  \item[$F$] – pradinių faktų aibė;
  \item[$G$] – ieškomas tikslas (faktas, kurį norime įrodyti).
\end{description}
Taisyklių aibei bendruoju atveju priklauso $n$ taisyklių, pavidalo:
$Ri: A \to B$, kur $A$ yra faktų aibė, o $B$ – pagal taisyklę
$Ri$ iš faktų $A$ išvedamas faktas.

Tiesioginio išvedimo sistema bando išvesti ieškomąjį faktą $G$
tikrindama visas taisykles ir iš jų pritaikydama tas, kurių
prielaidos yra tarp jau išvestų faktų ir kurias panaudojant išvedamų
faktų dar nėra tarp rezultatų, tol kol yra gaunamas ieškomas tikslas
arba nebėra taisyklių, kurias galima būtų pritaikyti.

\section{Pseudo kodas}

\label{sec:fc:pseudo}

Pradiniai duomenys:
\begin{description}
  \item[$R$] – taisyklių aibė.
  \item[$F$] – pradinių faktų aibė.
  \item[$G$] – ieškomas tikslas.
\end{description}

Rezultatas:
\begin{description}
  \item[$Q$] – panaudotų taisyklių seka.
\end{description}
\begin{algorithmic}[1]
  \Function{tiesioginis išvedimas}{$R, F, G$}
    \State $Q := \left(  \right)$
    \State $R :=$ pirma iš taisyklių;
    \While{yra pritaikomų taisyklių $\land G \not\in F$}
                                        \label{fc:pseudo:while_condition}
      \If{$R$ prielaidos yra tarp $F \land R$ išvados nėra tarp $F$}
                                        \label{fc:pseudo:if_condition}
        \State $R$ išvadą pridedame į $F$;
                                        \label{fc:pseudo:add_fact}
        \State $R := $ pirma iš taisyklių;
                                        \label{fc:pseudo:start}
        \State $R$ pridedame į $Q$ galą;
                                        \label{fc:pseudo:add_rule}
      \Else
        \State $R := $ kita taisyklė;   \label{fc:pseudo:next_rule}
      \EndIf
    \EndWhile
    \State \Return Q;
  \EndFunction
\end{algorithmic}

\section{Realizacija}

Tiesioginio išvedimo sistema parašyta naudojant Python programavimo
kalbą. Sistema susideda iš trijų modulių:
\begin{enumerate}
  \item \verb|utils| – pagalbinės funkcijos ir klasės;
  \item \verb|forwardchaining| – modulis, kuriame realizuotas
    tiesioginio išvedimo funkcionalumas;
  \item \verb|main| – vykdomasis modulis.
\end{enumerate}

\begin{sloppypar}
Visi duomenys (produkcijų sistema) yra saugomi klasėje
\verb|ProductionSystem|. Klasės \verb|ForwardChaining| tipo objektas
gauna rezultatą (taisykles, kurias reikia pritaikyti norint pasiekti
tikslą) manipuliuodamas susikurtu \verb|ProductionSystem| objektu.
Visus duomenis sistema išveda \LaTeX transliatoriui suprantamu formatu:
dėl to visi šiame dokumente pateikti pavyzdžiai iš tiesų yra
sistemos išvestis. Konkrečius programai pateiktus duomenis
galima pamatyti atsidarius šio dokumento išeities tekstą. (Buvo
nuspręsta jų dokumente nerodyti, nes sistema darbo pradžioje išveda
gautus duomenis – tai yra, informacija būtų dubliuojama.)
\end{sloppypar}

Tiesioginio išvedimo algoritmas, pateiktas \ref{sec:fc:pseudo}
skyrelyje, siekiant išvengti netinkamo programavimo stiliaus Python
kalba, buvo realizuotas \emph{while} ir \emph{kita taisyklė}
konstrukcijas pakeičiant į rekursiją bei iteratorių:

\pythonai{source}{forwardchaining.ForwardChaining.recursion}

\section{Pavyzdžiai}

\subsection{Pirmasis pavyzdys: paprastas atvejis}

\begin{pythonaienv}[fc]
# Taisyklės:
FB Z                                    # R1: F, B → Z
CD F                                    # R2: C, D → F
A D                                     # R3: A → D
# Faktai:
ABC
# Tikslas:
Z
\end{pythonaienv}

\subsection{Antrasis pavyzdys: du išvedimo keliai}

\begin{pythonaienv}[fc]
# Taisyklės:
D Z                                     # R1: D → Z
C D                                     # R2: C → D
B C                                     # R3: B → C
A G                                     # R4: A → G
G Z                                     # R5: G → Z
A B                                     # R6: A → B
# Faktai:
A
# Tikslas:
Z
\end{pythonaienv}

\subsection{Trečiasis pavyzdys: du išvedimo keliai (taisyklės kita tvarka)}

\begin{pythonaienv}[fc]
# Taisyklės:
A G                                     # R1: A → G
D Z                                     # R2: D → Z
C D                                     # R3: C → D
B C                                     # R4: B → C
A B                                     # R5: A → B
G Z                                     # R6: G → Z
# Faktai:
A
# Tikslas:
Z
\end{pythonaienv}

\subsection{Ketvirtasis pavyzdys: didesnis testas}

\begin{pythonaienv}[fc]
# Taisyklės:
FB Z                                    # R1: F, B → Z
CD F                                    # R2: C, D → F
A D                                     # R3: A → D
A L                                     # R4: A → L
L K                                     # R5: L → K
B A                                     # R6: B → A
D M                                     # R7: D → M
# Faktai:
ABC
# Tikslas:
Z
\end{pythonaienv}

\subsection{Penktasis pavyzdys: ilgas antecedentas}

\begin{pythonaienv}[fc]
# Taisyklės:
G Z                                     # R1: G → Z
A G                                     # R2: A → G
A B                                     # R3: A → B
B C                                     # R4: B → C
C D                                     # R5: C → D
D Z                                     # R6: D → Z
ABGCDZ H                                # R7: A, B, C, D, G, Z → H
# Faktai:
A
# Tikslas:
H
\end{pythonaienv}

\subsection{Šeštasis pavyzdys: išvedimas neegzistuoja}

\begin{pythonaienv}[fc]
# Taisyklės:
CD F                                    # R1: C, D → F
A D                                     # R2: A → D
A L                                     # R3: A → L
L K                                     # R4: L → K
B A                                     # R5: B → A
D M                                     # R6: D → M
FB Z                                    # R7: F, B → Z
# Faktai:
ABC
# Tikslas:
H
\end{pythonaienv}

\subsection{Septintasis pavyzdys: tikslas tarp prielaidų}

\begin{pythonaienv}[fc]
# Taisyklės:
CD F                                    # R1: C, D → F
A D                                     # R2: A → D
A L                                     # R3: A → L
L K                                     # R4: L → K
B A                                     # R5: B → A
D M                                     # R6: D → M
FB Z                                    # R7: F, B → Z
# Faktai:
ABC
# Tikslas:
B
\end{pythonaienv}

\subsection{Aštuntasis pavyzdys}

\begin{pythonaienv}[fc]

# Taisyklės:
A L                                     # R1: A → L
L K                                     # R2: L → K
D A                                     # R3: D → A
D M                                     # R4: D → M
EFB Z                                   # R5: E, F, B → Z
ECD F                                   # R6: E, C, D → F
EA D                                    # R7: E, A → D

# Faktai:
A B C E

# Tikslas:
Z

\end{pythonaienv}
