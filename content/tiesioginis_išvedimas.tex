\chapter{Tiesioginis išvedimas}

\section{TODO}


TODO: Žr. naujausią darbą, kaip pavyzdį.

Padaryti, kad grafai užimtų mažiau vietos. Tarpinius grafus pakeisti
į tekstą.

Rekursijos negali būti pseudo kode. Reikia pridėti paaiškinią, kodėl
Python realizacija yra padaryta panaudojant rekursiją.

Tiesioginis išvedimas: iki kovo pabaigos.
Atbulinis išvedimas: iki balandžio pabaigos.

Aprašyti uždavinį.

Prie pseudo kodo nurodyti, kas yra input, kas yra output.
Input:

1)  Produkcijų aibė. RULES
2)  Faktai. FACTS
3)  Tikslas. GOAL

Output: Produkcijų seka. RESULT

Sunumeruoti pseudo kodo eilutes ir realaus kodo komentaruose
nurodyti atitinkamas eilutes.

Aprašyti programos „modulius“ ir jų struktūrą. Aprašyti detaliai
programą, kaip jai paduoti duomenis ir t.t.
Aprašyti kaip laikomi duomenų struktūra.

\section{Įvadas}

Tiesioginis išvedimas yra vienas iš dviejų pagrindinių išvedimo metodų,
naudojamų su produkcijos taisyklėmis, ir logikoje gali būti
apibrėžtas, kaip pakartotinas \emph{modus ponens} taisyklės
taikymas.

Tiesioginio išvedimo uždavinį galime apibrėžti, kaip trejetą
$<R, F, G>$, kur
\begin{description}
  \item[$R$] – taisyklių aibė;
  \item[$F$] – pradinių faktų aibė;
  \item[$G$] – ieškomas tikslas (faktas, kurį norime įrodyti).
\end{description}
Taisyklių aibei bendruoju atveju priklauso $n$ taisyklių, pavidalo:
$Ri: A \to B$, kur $A$ yra faktų aibė, o $B$ – pagal taisyklę
$Ri$ iš faktų $A$ išvedamas faktas.

Tiesioginio išvedimo sistema bando išvesti ieškomąjį faktą $G$
tikrindama visas taisykles ir iš jų pritaikydama tas, kurių
prielaidos yra tarp jau išvestų faktų ir kurias panaudojant išvedamų
faktų dar nėra tarp rezultatų, tol kol yra gaunamas ieškomas tikslas
arba nebėra taisyklių, kurias galima būtų pritaikyti.

\section{Pseudo kodas}

\label{sec:fc:pseudo}

\begin{description}
  \item[$R$] – nepanaudotų taisyklių aibė.
  \item[$F$] – pradinių faktų aibė.
  \item[$G$] – ieškomas tikslas.
  \item[$Q$] – panaudotų taisyklių seka.
\end{description}
\begin{algorithmic}[1]
  \Function{tiesioginis išvedimas}{$R, F, G$}
    \State $Q := \left(  \right)$
    \State $R :=$ pirma iš taisyklių;
    \While{yra pritaikomų taisyklių $\land G \not\in F$}
      \If{$R$ prielaidos yra tarp $F \land R$ išvados nėra tarp $F$}
        \State $R$ išvadą pridedame į $F$;
        \State $R := $ pirma iš taisyklių;
        \State $R$ pridedame į $Q$ galą;
      \Else
        \State $R := $ kita taisyklė;
      \EndIf
    \EndWhile
    \State \Return Q;
  \EndFunction
\end{algorithmic}

\section{Realizacija}

Tiesioginio išvedimo sistema parašyta naudojant Python programavimo
kalbą. Sistema susideda iš trijų modulių:
\begin{itemize}
  \item \verb|utils| – pagalbinės funkcijos ir klasės;
  \item \verb|forwardchaining| – modulis, kuriame realizuotas
    tiesioginio išvedimo funkcionalumas;
  \item \verb|main| – vykdomasis modulis.
\end{itemize}

\begin{sloppypar}
Visi duomenys (produkcijų sistema) yra saugomi klasėje
\verb|ProductionSystem|. Klasės \verb|ForwardChaining| tipo objektas
gauna rezultatą (taisykles, kurias reikia pritaikyti norint pasiekti
tikslą) manipuliuodamas susikurtu \verb|ProductionSystem| objektu.
Visus duomenis sistema išveda \LaTeX transliatoriui suprantamu formatu:
dėl to visi šiame dokumente pateikti pavyzdžiai iš tiesų yra
sistemos sugeneruota išvestis. Konkrečius programai pateiktus duomenis
galima pamatyti atsidarius šio dokumento išeities tekstą. (Buvo
nuspręsta jų dokumente nerodyti, nes sistema darbo pradžioje išveda
gautus duomenis – tai yra, informacija būtų dubliuojama.)
\end{sloppypar}

Tiesioginio išvedimo algoritmas, pateiktas \nameref{sec:fc:pseudo}
skyrelyje, siekiant išvengti netinkamo programavimo stiliaus Python
kalba, buvo realizuotas \emph{while} ir \emph{kita taisyklė}
konstrukcijas pakeičiant į rekursiją bei iteratorių:

\pythonai{source}{forwardchaining.ForwardChaining.recursion}

\section{Pavyzdžiai}

\subsection{Pirmas pavyzdys}

\begin{pythonaienv}[fc]
# Taisyklės:
FB Z                                    # R1: F, B → Z
CD F                                    # R2: C, D → F
A D                                     # R3: A → D
A L                                     # R4: A → L
L K                                     # R5: L → K
B A                                     # R6: B → A
D M                                     # R7: D → M
# Faktai:
ABC
# Tikslas:
Z
\end{pythonaienv}

\subsection{Antras pavyzdys}

\begin{pythonaienv}[fc]
# Taisyklės:
G Z                                     # R1: G → Z
A G                                     # R2: A → G
A B                                     # R3: A → B
B C                                     # R4: B → C
C D                                     # R5: C → D
D Z                                     # R6: D → Z
# Faktai:
A
# Tikslas:
Z
\end{pythonaienv}

\subsection{Trečias pavyzdys}

\begin{pythonaienv}[fc]
# Taisyklės:
CD F                                    # R1: C, D → F
A D                                     # R2: A → D
A L                                     # R3: A → L
L K                                     # R4: L → K
B A                                     # R5: B → A
D M                                     # R6: D → M
FB Z                                    # R7: F, B → Z
# Faktai:
ABC
# Tikslas:
Z
\end{pythonaienv}

\subsection{Ketvirtas pavyzdys}

\begin{pythonaienv}[fc]
# Taisyklės:
CD F                                    # R1: C, D → F
A D                                     # R2: A → D
A L                                     # R3: A → L
L K                                     # R4: L → K
B A                                     # R5: B → A
D M                                     # R6: D → M
FB Z                                    # R7: F, B → Z
# Faktai:
ABC
# Tikslas:
H
\end{pythonaienv}

\subsection{Penktas pavyzdys}

\begin{pythonaienv}[fc]
# Taisyklės:
CD F                                    # R1: C, D → F
A D                                     # R2: A → D
A L                                     # R3: A → L
L K                                     # R4: L → K
B A                                     # R5: B → A
D M                                     # R6: D → M
FB Z                                    # R7: F, B → Z
# Faktai:
ABC
# Tikslas:
B
\end{pythonaienv}

\subsection{Šeštas pavyzdys}

\begin{pythonaienv}[fc]

# Taisyklės:
A L                                     # R1: A → L
L K                                     # R2: L → K
D A                                     # R3: D → A
D M                                     # R4: D → M
EFB Z                                   # R5: E, F, B → Z
ECD F                                   # R6: E, C, D → F
EA D                                    # R7: E, A → D

# Faktai:
A B C E

# Tikslas:
Z

\end{pythonaienv}
